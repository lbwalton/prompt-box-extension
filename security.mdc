# Security Rules & Guidelines

## 1. Authentication & Authorization Rules

### User Authentication Best Practices
- **Use strong password policies**: Minimum 12 characters, require uppercase, lowercase, numbers, and special characters
- **Implement account lockout**: Lock accounts after 5 failed attempts for 15 minutes
- **Use secure password hashing**: Always use bcrypt, Argon2, or PBKDF2 with salt rounds â‰¥12
- **Implement password history**: Prevent reuse of last 5 passwords
- **Require password expiration**: Force password changes every 90 days

### Session Management Guidelines
- **Use secure session tokens**: Generate cryptographically secure random tokens (32+ characters)
- **Set appropriate session timeouts**: 15 minutes for sensitive operations, 4 hours for regular sessions
- **Implement session invalidation**: Clear sessions on logout and password change
- **Use secure cookies**: Set `HttpOnly`, `Secure`, and `SameSite=Strict` flags
- **Store session data securely**: Use server-side storage, never client-side

### Role-Based Access Control Rules
- **Implement principle of least privilege**: Users get minimum permissions needed
- **Use role hierarchies**: Define clear role relationships and inheritance
- **Audit permissions regularly**: Review and update access rights quarterly
- **Implement attribute-based access control**: Consider user context, time, location
- **Document all roles**: Maintain clear documentation of permissions per role

### Multi-Factor Authentication Requirements
- **Require MFA for admin accounts**: All administrative access must use MFA
- **Support multiple MFA methods**: TOTP, SMS, hardware tokens, biometric
- **Implement backup codes**: Provide 10 backup codes for account recovery
- **Allow MFA bypass only with approval**: Require manager approval for exceptions
- **Monitor MFA usage**: Track and alert on MFA bypass events

## 2. Input Validation & Sanitization

### Data Validation Rules for All Inputs
- **Validate all inputs**: Never trust client-side validation alone
- **Use whitelist approach**: Only allow known good characters/patterns
- **Implement length limits**: Set maximum lengths for all input fields
- **Validate data types**: Ensure inputs match expected data types
- **Sanitize before storage**: Clean data before database insertion

### SQL Injection Prevention
- **Use parameterized queries**: Always use prepared statements or ORM
- **Never concatenate SQL**: Avoid string concatenation for SQL queries
- **Validate database permissions**: Use least privilege database accounts
- **Escape special characters**: If dynamic SQL is unavoidable, escape properly
- **Use stored procedures**: Prefer stored procedures over dynamic SQL

### XSS (Cross-Site Scripting) Prevention
- **Output encoding**: HTML encode all user-supplied data before output
- **Use Content Security Policy**: Implement CSP headers with strict rules
- **Validate content types**: Ensure proper MIME types for file uploads
- **Use framework protections**: Leverage built-in XSS protections
- **Regular security testing**: Test for XSS vulnerabilities regularly

### CSRF (Cross-Site Request Forgery) Protection
- **Use CSRF tokens**: Include unique tokens in all forms
- **Validate token on submission**: Check token validity server-side
- **Set SameSite cookies**: Use `SameSite=Strict` for session cookies
- **Implement double-submit**: Use both cookie and form token validation
- **Check referrer headers**: Validate request origins when possible

## 3. Data Protection & Privacy

### Encryption Requirements (At Rest and In Transit)
- **Encrypt data in transit**: Use TLS 1.3 for all communications
- **Encrypt data at rest**: Use AES-256 for database and file encryption
- **Encrypt backups**: All backup data must be encrypted
- **Use key management**: Implement proper key rotation and management
- **Encrypt sensitive fields**: Hash passwords, encrypt PII separately

### PII (Personally Identifiable Information) Handling
- **Minimize PII collection**: Only collect necessary personal data
- **Anonymize when possible**: Use pseudonyms for non-essential operations
- **Implement data masking**: Mask sensitive data in logs and displays
- **Use encryption for PII**: Encrypt all PII fields in database
- **Document PII handling**: Maintain clear documentation of PII processing

### Data Retention Policies
- **Define retention periods**: Set clear time limits for data storage
- **Implement automatic deletion**: Automate data cleanup processes
- **Archive old data**: Move old data to secure archival storage
- **Document retention rules**: Maintain clear retention policy documentation
- **Regular policy review**: Review and update retention policies annually

### Secure Data Disposal
- **Secure deletion methods**: Use secure deletion algorithms (DoD 5220.22-M)
- **Physical media destruction**: Properly destroy physical storage media
- **Document disposal procedures**: Maintain disposal procedure documentation
- **Verify disposal completion**: Confirm successful data deletion
- **Maintain disposal logs**: Log all data disposal activities

## 4. API Security

### API Authentication Methods
- **Use OAuth 2.0**: Implement OAuth 2.0 for API authentication
- **JWT tokens**: Use signed JWT tokens with appropriate expiration
- **API keys**: Use secure API keys for service-to-service communication
- **Certificate-based auth**: Use client certificates for high-security APIs
- **Implement token refresh**: Use refresh tokens for long-lived sessions

### Rate Limiting Rules
- **Implement rate limiting**: Set appropriate limits per user/IP
- **Use sliding windows**: Implement sliding window rate limiting
- **Differentiate by endpoint**: Set different limits for different endpoints
- **Monitor rate limit usage**: Track and alert on rate limit violations
- **Provide rate limit headers**: Include rate limit info in API responses

### Input/Output Validation
- **Validate all API inputs**: Use schema validation for all API requests
- **Sanitize API responses**: Clean sensitive data from API responses
- **Use consistent error formats**: Standardize API error response format
- **Implement request size limits**: Set maximum request body sizes
- **Validate content types**: Ensure proper Content-Type headers

### Error Handling Without Information Disclosure
- **Use generic error messages**: Don't reveal system internals in errors
- **Log detailed errors server-side**: Keep detailed error logs internally
- **Implement proper HTTP status codes**: Use appropriate status codes
- **Sanitize error responses**: Remove sensitive data from error messages
- **Monitor error patterns**: Track and alert on unusual error patterns

## 5. Infrastructure Security

### HTTPS/TLS Requirements
- **Enforce HTTPS everywhere**: Redirect all HTTP to HTTPS
- **Use strong cipher suites**: Prefer TLS 1.3 with strong ciphers
- **Implement HSTS**: Use HTTP Strict Transport Security headers
- **Regular certificate management**: Monitor and renew certificates
- **Use certificate pinning**: Implement certificate pinning for critical services

### Database Security Practices
- **Use connection encryption**: Encrypt database connections
- **Implement least privilege**: Use minimal database permissions
- **Regular security updates**: Keep database software updated
- **Network isolation**: Place databases in private subnets
- **Monitor database access**: Log and monitor all database connections

### Environment Variable Management
- **Use secure secret management**: Use tools like HashiCorp Vault or AWS Secrets Manager
- **Never commit secrets**: Never store secrets in version control
- **Rotate secrets regularly**: Implement automatic secret rotation
- **Use different secrets per environment**: Separate dev/staging/prod secrets
- **Monitor secret access**: Track and alert on secret usage

### Dependency Security (Keeping Packages Updated)
- **Regular dependency updates**: Update dependencies monthly
- **Automated vulnerability scanning**: Use tools like Snyk or Dependabot
- **Pin dependency versions**: Use exact versions, not ranges
- **Monitor security advisories**: Subscribe to security notifications
- **Test updates thoroughly**: Test all dependency updates before deployment

## 6. Code Security

### Secure Coding Practices
- **Follow OWASP guidelines**: Adhere to OWASP Top 10 recommendations
- **Use secure defaults**: Configure security features by default
- **Implement defense in depth**: Use multiple security layers
- **Fail securely**: Handle errors without compromising security
- **Use security linters**: Implement security-focused code analysis

### Common Vulnerabilities to Avoid
- **Buffer overflows**: Use safe string handling functions
- **Integer overflow**: Validate numeric inputs and use safe math
- **Race conditions**: Use proper synchronization mechanisms
- **Insecure deserialization**: Validate all serialized data
- **Insecure direct object references**: Use indirect references

### Code Review Security Checklist
- **Authentication checks**: Verify all endpoints require authentication
- **Authorization validation**: Ensure proper permission checks
- **Input validation**: Confirm all inputs are validated
- **Output encoding**: Check for proper output encoding
- **Error handling**: Verify secure error handling
- **Logging**: Ensure sensitive data isn't logged
- **Dependencies**: Review for known vulnerabilities

### Testing Security Requirements
- **Automated security testing**: Implement SAST and DAST tools
- **Penetration testing**: Conduct regular penetration tests
- **Security unit tests**: Write tests for security functions
- **Integration security tests**: Test security across components
- **Vulnerability scanning**: Regular automated vulnerability scans

## 7. Monitoring & Logging

### Security Event Logging
- **Log all security events**: Authentication, authorization, data access
- **Use structured logging**: Implement consistent log format
- **Include relevant context**: User, IP, timestamp, action details
- **Protect log integrity**: Use write-once logging where possible
- **Centralize log collection**: Use centralized logging system

### Audit Trail Requirements
- **Comprehensive audit trail**: Log all data access and modifications
- **Immutable audit logs**: Prevent log tampering
- **Long-term retention**: Retain audit logs for compliance period
- **Searchable logs**: Implement log search and analysis capabilities
- **Regular audit reviews**: Conduct quarterly audit log reviews

### Incident Response Procedures
- **Define incident categories**: Classify incidents by severity
- **Establish response team**: Define roles and responsibilities
- **Create response playbooks**: Document step-by-step procedures
- **Implement escalation procedures**: Define escalation criteria
- **Post-incident analysis**: Conduct lessons learned reviews

### Security Monitoring Guidelines
- **Real-time monitoring**: Monitor security events in real-time
- **Automated alerting**: Set up automated security alerts
- **Baseline establishment**: Establish normal behavior baselines
- **Anomaly detection**: Implement anomaly detection systems
- **Regular monitoring reviews**: Review monitoring effectiveness monthly

## Implementation Examples

### Authentication Implementation (Node.js/Express)
```javascript
// Use bcrypt for password hashing
const bcrypt = require('bcrypt');
const saltRounds = 12;

// Hash password
const hashedPassword = await bcrypt.hash(password, saltRounds);

// Verify password
const isValid = await bcrypt.compare(password, hashedPassword);
```

### Input Validation (Express.js)
```javascript
const { body, validationResult } = require('express-validator');

const validateUser = [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 12 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])/),
  body('username').isLength({ min: 3, max: 30 }).matches(/^[a-zA-Z0-9_]+$/),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    next();
  }
];
```

### CSRF Protection (Express.js)
```javascript
const csrf = require('csurf');
const csrfProtection = csrf({ cookie: true });

// Apply to all routes
app.use(csrfProtection);

// Include token in forms
app.get('/form', (req, res) => {
  res.render('form', { csrfToken: req.csrfToken() });
});
```

### Rate Limiting (Express.js)
```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP'
});

app.use('/api/', limiter);
```

## Compliance and Standards

- **GDPR Compliance**: Implement data protection by design and default
- **SOC 2 Type II**: Maintain security controls for SOC 2 compliance
- **PCI DSS**: Follow PCI DSS requirements for payment processing
- **ISO 27001**: Align with ISO 27001 information security standards
- **OWASP ASVS**: Follow OWASP Application Security Verification Standard

## Regular Security Activities

### Monthly
- Dependency vulnerability scanning
- Security patch application
- Access rights review
- Security monitoring review

### Quarterly
- Penetration testing
- Security training updates
- Policy review and updates
- Incident response drills

### Annually
- Comprehensive security audit
- Security architecture review
- Compliance assessment
- Security strategy updates

---

**Remember**: Security is everyone's responsibility. These rules should be integrated into your development workflow and regularly reviewed and updated based on emerging threats and best practices.
description:
globs:
alwaysApply: false
---